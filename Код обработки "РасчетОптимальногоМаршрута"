&НаКлиенте
Процедура ПриОткрытии(Отказ)
    
    ТранспортноеСредствоГосНомер = ВладелецФормы.Объект.АвтомобильГосударственныйНомер;
    Если ЗначениеЗаполнено(ТранспортноеСредствоГосНомер) Тогда
        
        Объект.ТранспортноеСредство = ПоискТранспортногоСредства(ТранспортноеСредствоГосНомер);
        ПолучениеИнформацииОТранспорте(Объект.ТранспортноеСредство);
        
    КонецЕсли;
    
    Для каждого  ТекущаяСтрокаТранспортной из ВладелецФормы.Объект.ДокументыОснования Цикл  
        //из ТЧ транспортной накладной собираются документы с типом "реализация.."
        Если ТипЗнч(ТекущаяСтрокаТранспортной.ДокументОснование) = Тип("ДокументСсылка.РеализацияТоваровУслуг") Тогда
            Строка = Объект.Адреса.Добавить();
            Строка.Документ = ТекущаяСтрокаТранспортной.ДокументОснование;
            АдресДокумента = АдресаДокументПриИзмененииНаСервере(Строка.Документ); 
            Если НЕ ЗначениеЗаполнено(АдресДокумента) Тогда
                Сообщить("" + Строка.Документ + " не имеет адреса доставки, поэтому не учитывается в маршруте!");
                Объект.Адреса.Удалить(Строка);
            Иначе
                Строка.Адрес = АдресДокумента;	
            КонецЕсли; 				
        КонецЕсли
    КонецЦикла;
    
    //при открытии формы столбцы ОТ и ДО будут заполнены в обоих ТЧ
    Объект.Маршруты.Добавить();
    //Объект.ВремяМаршрутов.Добавить();
    Для Номер = 0 по Объект.Адреса.Количество() - 1 Цикл
        Объект.Маршруты[Номер].До = Объект.Адреса[Номер].Адрес;	
        Объект.Маршруты.Добавить();
        Объект.Маршруты[Номер + 1].От = Объект.Адреса[Номер].Адрес; 
        
    КонецЦикла;
    
    Накладная = ВладелецФормы.Объект.Ссылка;   
    
    Если ЗначениеЗаполнено(Объект.APIКлюч) Тогда
        ЗаполнениеПоляHTML();
        APIВведен = Истина;
    Иначе
        Сообщить("Для работы необходимо ввести API ключ"); 
        APIВведен = Ложь;
    КонецЕсли;
    
    
    //1-й способ чтения html
    //   ПутьКФайлу = "C:\Users\arina\OneDrive\Документы\InfoBase2\html.txt";
    //   
    //   ТекстовыйФайл = Новый ТекстовыйДокумент;
    //
    //   ТекстовыйФайл.Прочитать(
    //       ПутьКФайлу,
    //       КодировкаТекста.UTF8, 
    //       Символы.ВК + Символы.ПС
    //   );
    //   
    //   Объект.ПолеЯндексКарты = ТекстовыйФайл.ПолучитьТекст();
    
    //2-й способ чтения htm
    //ПолучениеКарты();  	
    
    //Сообщить(ВладелецФормы.Элементы.ДокументыОснования.ПутьКДанным);
    //для 2го способа чтения html
    //&НаСервере
    //Функция ПолучениеКарты()
    //	
    //	 Текст =  Документы.Рейс.ПолучитьМакет("HTML").ПолучитьТекст();
    //	 Объект.ПолеЯндексКарты = Текст;	   
    //	
    //КонецФункции
КонецПроцедуры 

&НаСервере
Функция ПоискТранспортногоСредства(ГосНомер)
    Запрос = Новый Запрос;
    Запрос.Текст = 
    "ВЫБРАТЬ
    |	ТранспортныеСредства.Ссылка КАК Ссылка
    |ИЗ
    |	Справочник.ТранспортныеСредства КАК ТранспортныеСредства
    |ГДЕ
    |	ТранспортныеСредства.Код = &ГосНомер";
    
    Запрос.УстановитьПараметр("ГосНомер", ГосНомер);
    
    РезультатЗапроса = Запрос.Выполнить();
    
    ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
    
    Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
        Возврат ВыборкаДетальныеЗаписи.Ссылка;
    КонецЦикла;
    Сообщить("Транспортного средства с таким номером  нет в базе данных");
    Возврат Неопределено;
       
КонецФункции

&НаСервере
Процедура ЗаполнениеПоляHTML()
    
    html = "
    |<!DOCTYPE HTML>
    |<html xmlns=""http://www.w3.org/1999/xhtml"">
    |
    |<head>
    |<meta http-equiv=""Content-Type"" content=""text/html; charset=utf-8"" />
    |<meta http-equiv=""X-UA-Compatible"" content=""IE=8"" />
    |<style type=""text/css"">
    |	html {
    |		height: 100%
    |	}
    |	body {
    |		height: 100%;
    |		margin: 0px;
    |		padding: 0px
    |	}
    |	#map {
    |		height: 100%;
    |		width: 100%
    |	}
    |</style>
    |<script src=""https://api-maps.yandex.ru/2.1/?lang=ru_RU"" type=""text/javascript""></script>
    |<script src=""http://yandex.st/jquery/1.6.4/jquery.min.js"" type=""text/javascript""></script>
    |<script src=""https://api-maps.yandex.ru/2.1/?apikey=" +Объект.APIКлюч+"&lang=ru_RU"" type=""text/javascript""></script>
    |<script type=""text/javascript"">
    |	var myMap;
    |	let array = []; //неотсортированный маршрут
    |	let roads = []; //матрица с расстояниями между неотсортированными точками
    |	let townsArr = []; //правильный-отсортированный маршрут (1й и последний элемент это всегда точка отправления)-- конечный массив с маршрутом
    |	let townsDist = [];  //расстояния между  отсортированными адресами в массиве townsArr -- конечный массив с расстояниями 
    |	let times = [];     // матрица со временем пути между точками неотсортированными
    |	let townsTimes = [];  // время пути между отсортированными точками  в townsArr - конечный массив с временем
    |
    |	ymaps.ready(init);
    |   //инициация карты
    |	function init() {
    |		
    |		var buttonEditor = new ymaps.control.Button({
    |    		data: { content: 'Режим редактирования' },
    |			options: { maxWidth: [200, 200, 250]}
    |		
    |		});
    |
    |		buttonEditor.events.add('select', function () {
    |    		multiRoute.editor.start({
    |        		addWayPoints: false,
    |        		removeWayPoints: false,
    |				dragWayPoints: false
    |    		});
    |		});
    |      	
    |		buttonEditor.events.add('deselect', function () {
    |    		// Выключение режима редактирования.
    |    		multiRoute.editor.stop();
    |		});
    |		myMap = new ymaps.Map(""map"", {
    |			center: [57.626559, 39.893813], // Ярославль
    |			zoom: 11,
    |			controls: ['default', buttonEditor]
    |		});
    |
    |	
    |		myMap.behaviors.enable('scrollZoom');
    |		myMap.behaviors.disable('dblClickZoom');		
    |	};
    |	
    |	function Reset() {
    |		myMap.geoObjects.removeAll();
    |	}
    |		
    |	function FindAdres(Adres) {
    |		Reset();
    |		var myGeocoder = ymaps.geocode(Adres);
    |		myGeocoder.then(
    |		function (res) {
    |			var firstGeoObject = res.geoObject.get(0);
    |			if (firstGeoObject != null) {
    |				myMap.panTo(
    |				firstGeoObject.geometry.getCoordinates(), {
    |				checkZoomRange: true,
    |				flying: false,
    |				safe: true
    |		});
    |
    |		myPlacemark = new ymaps.Placemark(firstGeoObject.geometry.getCoordinates(), {
    |			iconContent: Adres
    |		}, {
    |			preset: 'islands#blueStretchyIcon'
    |		});
    |			myMap.geoObjects.add(myPlacemark);
    |		}
    |			else {
    |				alert(""Ничего не найдено"");
    |				}
    |			}
    |			);
    |	}
    |					
    |	function GeolocateMe() {
    |		var geolocation;
    |		geolocation = ymaps.geolocation;
    |			  geolocation.get({
    |			  provider: 'yandex',
    |		mapStateAutoApply: true
    |		}).then(function (result) {
    |			result.geoObjects.Option.set('preset', 'islands#redCircleIcon');
    |			result.geoObjects.get(0).properties.set({
    |			hasBalloon: false,
    |		});
    |			myMap.geoObjects.add(result.geoObjects);
    |		});	
    |			geolocation.get({
    |			provider: 'browser',
    |			mapStateAutoApply: true
    |		}).then(function (result) {
    |			result.geoObjects.options.set('preset', 'islands#blueCircleIcon');
    |			myMap.geoObjects.add(results.geoObjects);
    |			});
    |	}	
    |
    |	function GetMultiRoute(towns) {
    |		Reset();
    |		routes = towns;
    |		// Создаем мультимаршрут
    |		multiRoute = new ymaps.multiRouter.MultiRoute({
    |		referencePoints: routes,
    |		params: {
    |			routingMode: 'auto'
    |		}
    |		}, {
    |			editorDrawOver: false,
    |			boundsAutoApply: true,
    |			editorMidPointsType: 'via'	
    |		});
    |		myMap.geoObjects.add(multiRoute);
    |	}
    |
    |	function recalculate(){ 
    |		let dist = [];
    |		let durations = [];
    |		var activeRoute = multiRoute.getActiveRoute();
    |    		// Получение коллекции путей активного маршрута.
    |    	var activeRoutePaths = activeRoute.getPaths(); 
    |    		// Проход по коллекции путей.
    |    	activeRoutePaths.each(function(path) {
    |			let d = path.properties.get('distance').text;
    |			let t = path.properties.get('duration').text;
    |        	dist.push(d.slice(0, d.length - 3));
    |        	durations.push(t);
    |    	});
    |       let o = document.createEvent('MouseEvents');
    |	    o.initEvent('click', true, true);
    |		o.dist = dist.join('~');
    |		o.times = durations.join('|');
    |		o.eventType = 'Перерасчет';
    |	    document.body.dispatchEvent(o);
    |	}
    |
    |
    |	async function GetRoute(pointA, pointB) {
    |		Reset();
    |		routes = [pointA, pointB];
    |		// Создаем мультимаршрут
    |		multiRoute = new ymaps.multiRouter.MultiRoute({
    |		referencePoints: routes,
    |		params: {
    |			routingMode: 'auto'
    |		}
    |		}, {
    |			editorDrawOver: false,
    |			boundsAutoApply: true
    |		});					
    |		myMap.geoObjects.add(multiRoute);
    |		let route = await ymaps.route([pointA, pointB]);
    |		//Находит расстояние между точками
    |		let distance = (route.getLength()/1000).toFixed(2);
    |		townsArr.push(pointA);
    |		townsArr.push(pointB);
    |		townsArr.push(pointA);
    |
    |		//находит время пути между точками
    |		let timeRoute = route.getHumanTime();
    |
    |		//тут хранятся расстояния
    |       townsDist.push(distance);
    |		townsDist.push(distance);
    |		//тут хранится время
    |		townsTimes.push(timeRoute);
    |		townsTimes.push(timeRoute);
    |
    |		//создается событие клика о
    |		let o = document.createEvent('MouseEvents');
    |	    o.initEvent('click', true, true);
    |		o.routes = townsArr.join('~');
    |		o.dist = townsDist.join('~');
    |		o.times = townsTimes.join('|');
    |		o.eventType = 'Расчет';
    |	    document.body.dispatchEvent(o);
    |			townsDist = [];
    |			townsArr = [];
    |			townsTimes = [];
    |	}
    |
    |	async function getDistance(json) {
    |			let arr = JSON.parse(json);
    |			for(let i = 0; i <= arr.length - 2; i++) {
    |				for(let j = i + 1; j <= arr.length - 1; j++) { 
    |					try {
    |						let route = await ymaps.route([arr[i] , arr[j]]);
    |						let distance = (route.getLength()/1000).toFixed(2); 
    |						let div = document.createElement(""div"");
    |      					div.setAttribute(""data-from"", arr[i]);
    |      					div.setAttribute(""data-to"", arr[j]);
    |      					div.setAttribute(""data-distance"", distance);
    |      					div.setAttribute(""class"", ""dist""); 
    |
    |                       let timeRoute = route.getHumanTime(); 
    |						div.setAttribute(""data-time"", timeRoute);
    |						div.innerHTML = arr[i] + ""-"" + arr[j] + ""="" + distance;
    |						div.style.display = 'none';
    |      					document.body.append(div);
    |					}
    |					catch(err) {
    |						alert('Не удалось построить маршрут. Проверьте правильность заполнения API-ключа и адресов!');
    |						return;
    |					}
    |				}
    |			} 
    |
    |			getArray();
    |			//alert('Оптимальный маршрут найден');
    |
    |			let divs = document.querySelectorAll("".dist"");
    |           divs.forEach((div) => {
    |        		div.remove();
    |			});
    |
    |			let o = document.createEvent('MouseEvents');
    |	        o.initEvent('click', true, true);
    |			o.routes = townsArr.join('~');
    |			for (let ind = 0; ind < townsArr.length - 1; ind++) {
    |				let i = array.indexOf(townsArr[ind]); //берется адрес из отсорт. массива и находится индекс этого адреса в неотсортированном массиве
    |				let j = array.indexOf(townsArr[ind + 1]);
    |            	townsDist.push(roads[i][j]); //по этим индексам строился массив roads, поэтому именно по этим индексам находится расстояние между адресами
    |				townsTimes.push(times[i][j]);
    |			}
    |			o.dist = townsDist.join('~');
    |			o.times = townsTimes.join('|');
    |           o.eventType = 'Расчет';
    |	        document.body.dispatchEvent(o);
    |
    |			array = [];
    |			roads = [];
    |			townsArr = [];
    |			townsDist = [];
    |			townsTimes = [];
    |			times = [];
    |  	}
    |	
    |   function getArray() {
    |    	let divs = document.querySelectorAll("".dist"");
    |    	divs.forEach((div) => {
    |        	if (!array.includes(div.dataset.from)) {
    |            	array.push(div.dataset.from);
    |        	}
    |        	if (!array.includes(div.dataset.to)) {
    |            	array.push(div.dataset.to);
    |        	}
    |		});  // заполняется массив неотсортированных городов 
    |		
    |    	roads = Array(array.length).fill().map(x => Array(array.length).fill(0));
    |		times = Array(array.length).fill().map(x => Array(array.length).fill('')); //пустые потому что время от яндекса приходит строкой
    |
    |    	divs.forEach((div) => {
    |        	let i = array.indexOf(div.dataset.from);
    |        	let j = array.indexOf(div.dataset.to);
    |
    |        	roads[i][j] = parseFloat(div.dataset.distance);
    |        	roads[j][i] = parseFloat(div.dataset.distance);
    |			times[i][j] = div.dataset.time;
    |        	times[j][i] = div.dataset.time;
    |    	});  
    |
    |   const N = roads.length;
    |	let final_path = Array (N + 1).fill (-1);
    |	let visited = Array (N).fill (false); 
    |	let final_res = Number.MAX_SAFE_INTEGER;
    |
    |	// Функция копирования временного пути в окончательный путь	
    |	function copyToFinal (curr_path){
    |        for (let i = 0; i < N; i++){
    |        	final_path[i] = curr_path[i];
    |        }
    |        final_path[N] = curr_path[0];
    |	}   
    |	
    |	// поиск минимальной стоимости ребра
    |	function firstMin (roads, i){
    |    let min = Number.MAX_SAFE_INTEGER;
    |    for (let k = 0; k < N; k++){
    |        if (roads[i][k] < min && i !== k){
    |                min = roads[i][k];
    |        }
    |    }
    |    return min;
    |	} 
    |
    |	function secondMin (roads, i){
    |    	let first = Number.MAX_SAFE_INTEGER;
    |    	let second = Number.MAX_SAFE_INTEGER;
    |    	for (let j = 0; j < N; j++){
    |        	if (i == j){
    |            	continue;
    |        	}
    |        	if (roads[i][j] <= first){
    |           	second = first;
    |            	first = roads[i][j];
    |        	}
    |        	else if (roads[i][j] <= second && roads[i][j] !== first){
    |            	second = roads[i][j];
    |        	}
    |		}
    |    return second;
    |	} 
    |
    |	function TSPRec (roads, curr_bound, curr_weight, level, curr_path)
    |	{   
	|    if (level == N){
    |         if (roads[curr_path[level - 1]][curr_path[0]] !== 0){
    |           // в curr_res указан общий вес полученного решения
    |			let curr_res = curr_weight + roads[curr_path[level - 1]][curr_path[0]];
    |         	//обновление пути
    |			if (curr_res < final_res){
    |            	copyToFinal (curr_path);
    |            	final_res = curr_res;
    |         	}
    |         }
    |    return;
    |    
    |	} 
	|	for (let i = 0; i < N; i++){
	|		// Рассмотрим следующую вершину, если она не совпадает с предыдущей 
	|		if (roads[curr_path[level - 1]][i] !== 0 && !visited[i]){
	|   		let temp = curr_bound;
	|			curr_weight += roads[curr_path[level - 1]][i];
	|       	if (level == 1){
	|           	curr_bound -= (firstMin (roads, curr_path[level - 1]) + firstMin (roads, i)) / 2;
	|    		}
	|    		else
	|      		{
	|           	curr_bound -= (secondMin (roads, curr_path[level - 1]) + firstMin (roads, i)) / 2;                
	|    		}
	|        	if (curr_bound + curr_weight < final_res){
	|        		curr_path[level] = i;
	|        		visited[i] = true;	           
	|        		TSPRec (roads, curr_bound, curr_weight, level + 1, curr_path);            
	|			} 
	|			// В противном случае нам придется отбросить вершину, сбросив значения в curr_weight и curr_bound
	|			curr_weight -= roads[curr_path[level - 1]][i];
	|       	curr_bound = temp;
	|			// сброс массива посещенных точек
	|       	visited.fill (false) 
	|       	for (var j = 0; j <= level - 1; j++)
	|           	visited[curr_path[j]] = true;        
	|		}    
	|	}
	|}
    |   //установка окончательног пути
    |	function TSP (roads){
    | 		let curr_path = Array (N + 1).fill (-1);   
    |   	let curr_bound = 0;
    |		visited.fill (false);   
    |		for (let i = 0; i < N; i++){
    |   		curr_bound += firstMin (roads, i) + secondMin (roads, i);
    |		}                                        
    |   	curr_bound = curr_bound == 1 ? (curr_bound / 2) + 1 : (curr_bound / 2);
    |   	visited[0] = true; 
    |		curr_path[0] = 0;
    |   	TSPRec (roads, curr_bound, 0, 1, curr_path);
    |
    |	}                
    |	TSP (roads);
    |   //alert(`Minimum cost:${final_res}`); 	
    |	townsArr = [];
    |	final_path.forEach((e) => {
    |		townsArr.push(array[e]);
    |	})
    |	
    |	GetMultiRoute(townsArr);	
    |  }												
    |													
    |</script>
    |</head>
    |<body>
    |	<div id=""map"" style=""width: 100%; height: 100%""></div>
    |</body>															
    |</html>";
    
    Объект.ПолеЯндексКарты = html;
    
КонецПроцедуры

&НаКлиенте
Процедура ВвестиAPIКлюч(Команда)
    Если ЗначениеЗаполнено(Объект.APIКлюч) Тогда
        ЗаполнениеПоляHTML();
        APIВведен = Истина;
    Иначе
        Сообщить("Для работы необходимо ввести API ключ!"); 
        APIВведен = Ложь;
    КонецЕсли;
КонецПроцедуры


&НаСервереБезКонтекста
Функция ПолучитьВременаМаршрута(Ссылка, От, До)
    
    Запрос = Новый Запрос;
    Запрос.Текст = 
    "ВЫБРАТЬ
    |	Рейс_ВремяМаршрутов.Авария КАК Авария,
    |	Рейс_ВремяМаршрутов.ОжидаемоеВремя КАК ОжидаемоеВремя,
    |	Рейс_ВремяМаршрутов.ФактВремя КАК ФактВремя
    |ИЗ
    |	РегистрСведений.Рейс_ВремяМаршрутов КАК Рейс_ВремяМаршрутов
    |ГДЕ
    |	Рейс_ВремяМаршрутов.ДокументМаршрута = &Ссылка
    |	И Рейс_ВремяМаршрутов.ТочкаОтправления = &От
    |	И Рейс_ВремяМаршрутов.ТочкаПрибытия = &До";
    
    Запрос.УстановитьПараметр("До", До);
    Запрос.УстановитьПараметр("От", От);
    Запрос.УстановитьПараметр("Ссылка", Ссылка);
    
    РезультатЗапроса = Запрос.Выполнить();
    
    ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
    СтруктураВремен = Новый Структура;
    Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
        
        Если НЕ ВыборкаДетальныеЗаписи.ОжидаемоеВремя = 0 И НЕ ВыборкаДетальныеЗаписи.ФактВремя = 0 Тогда
            СтруктураВремен.Вставить("ОжидаемоеВремя",ВыборкаДетальныеЗаписи.ОжидаемоеВремя);
            СтруктураВремен.Вставить("ФактическоеВремя",ВыборкаДетальныеЗаписи.ФактВремя); 
            СтруктураВремен.Вставить("Авария",ВыборкаДетальныеЗаписи.Авария);
        КонецЕсли;
        
    КонецЦикла;
    Возврат СтруктураВремен;
    
КонецФункции

//Нажатие кнопки "построить маршрут"
&НаКлиенте
Асинх Процедура НайтиРасстояния(Команда)
    Если ЗначениеЗаполнено(Объект.ТочкаОтправления) И ЗначениеЗаполнено(Объект.ТранспортноеСредство) И APIВведен Тогда 
        //Если Объект.Адреса.Количество() = 1 Тогда
        //	Строка = Объект.Адреса[0];
        //	Элементы.ПолеЯндексКарты.Документ.DefaultView.GetRoute(ТочкаОтправленияПриИзмененииНаСервере(), АдресаДокументПриИзмененииНаСервере(Строка.Документ));
        //	
        //	Элементы.ПолеЯндексКарты.Доступность = Ложь;
        //	Элементы.ПодтвердитьМаршрутИЗакрыть.Доступность = Ложь;
        //	Элементы.Подтвердить.Доступность = Ложь;	
        //Иначе
        Массив = Новый Массив;
        
        //сворачивание строк ТЧ-адреса, если документы одинаковые
        Если Объект.Адреса.Количество() >= 1 Тогда
            
            //КоличествоСтрок = Объект.Адреса.Количество();
            //Для Номер = 0  по КоличествоСтрок -  1 Цикл
            //	Если НЕ Номер >= КоличествоСтрок Тогда
            //		Строка1 = Объект.Адреса[Номер];
            //		Для Номер2 = Номер + 1  по КоличествоСтрок Цикл
            //			Если НЕ  Номер2 > Объект.Адреса.Количество() - 1   Тогда
            //				Строка2 = Объект.Адреса[Номер2];
            //				Если Строка1.Документ = Строка2.Документ Тогда
            //					Объект.Адреса.Удалить(Строка2);
            //					Номер2 = Номер2 - 1;
            //					КоличествоСтрок = КоличествоСтрок - 1;
            //				КонецЕсли;
            //			КонецЕсли;
            //		КонецЦикла;
            //	КонецЕсли;
            //КонецЦикла; 
            
            Массив.Добавить(ТочкаОтправленияПриИзмененииНаСервере());
            Для каждого Строка из Объект.Адреса Цикл
                Адрес = АдресаДокументПриИзмененииНаСервере(Строка.Документ);
                Если Массив.Найти(Адрес) = Неопределено Тогда
                    Массив.Добавить(Адрес);
                КонецЕсли;
            КонецЦикла;
            
            Если Массив.Количество() = 2 Тогда
                Элементы.ПолеЯндексКарты.Документ.DefaultView.GetRoute(Массив[0], Массив[1]);
            Иначе
                
                ЗаписьJSON = Новый ЗаписьJSON;               
                ЗаписьJSON.УстановитьСтроку();
                ЗаписатьJSON(ЗаписьJSON, Массив);  
                Результат = ЗаписьJSON.Закрыть();                                 
                
                Ждать Элементы.ПолеЯндексКарты.Документ.DefaultView.getDistance(Результат);  
                
            КонецЕсли;
            
            Элементы.ПолеЯндексКарты.Доступность = Ложь;
            Элементы.ПодтвердитьМаршрутИЗакрыть.Доступность = Ложь;
            Элементы.Подтвердить.Доступность = Ложь;
            
        Иначе
            Сообщить("Адреса не заполнены");	
        КонецЕсли;
        //КонецЕсли;
        
    Иначе
        Сообщить("Не заполнено: " + ?(ЗначениеЗаполнено(Объект.ТочкаОтправления), "", "Точка отправления; ") 
        + ?(ЗначениеЗаполнено(Объект.ТранспортноеСредство), "", "Транспортное средство; ")
        + ?(APIВведен, "", "API-Ключ; "));
    КонецЕсли;
    
КонецПроцедуры   

&НаСервереБезКонтекста
Функция ПолучитьРасходЛитровНаСервере(ТранспортныеСредства) 
    
    Запрос = Новый Запрос;
    Запрос.Текст = 
    "ВЫБРАТЬ
    |	РасходТопливаСрезПоследних.Литры КАК Литры
    |ИЗ
    |	РегистрСведений.Рейс_РасходТоплива.СрезПоследних(,ТранспортныеСредства = &ТранспортныеСредства) 
    |	КАК РасходТопливаСрезПоследних";
    
    Запрос.УстановитьПараметр("ТранспортныеСредства", ТранспортныеСредства);
    
    РезультатЗапроса = Запрос.Выполнить();
    
    ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
    
    Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
        Возврат ВыборкаДетальныеЗаписи.Литры;
    КонецЦикла;
    Возврат 0; 
КонецФункции

&НаКлиенте
Процедура ПолеЯндексКартыПриНажатии(Элемент, ДанныеСобытия, СтандартнаяОбработка)
    Если ЗначениеЗаполнено(ДанныеСобытия.event.eventType) Тогда
        РасходТоплива = ПолучитьРасходЛитровНаСервере(Объект.ТранспортноеСредство);//на 100км
        Если ДанныеСобытия.event.eventType = "Расчет" Тогда
            Если  ЗначениеЗаполнено(ДанныеСобытия.event.routes) 
                И ЗначениеЗаполнено(ДанныеСобытия.event.dist) 
                И ЗначениеЗаполнено(ДанныеСобытия.event.times) Тогда
                
                ПоказатьПредупреждение(, "Оптимальный маршрут найден",,"Информация"); 
                
                Адреса = СтрРазделить(ДанныеСобытия.event.routes, "~", Ложь); 
                Расстояния = СтрРазделить(ДанныеСобытия.event.dist, "~", Ложь);
                ВремяМаршрута = СтрРазделить(ДанныеСобытия.event.times, "|", Ложь);
                Объект.Маршруты.Очистить();
                //Объект.ВремяМаршрутов.Очистить();
                //заполнение ТЧ маршруты адресами и расстоянием
                Для Номер = 0 по Адреса.Количество() - 2 Цикл
                    Строка = Объект.Маршруты.Добавить();
                    Строка.От = Адреса[Номер];
                    Строка.До = Адреса[Номер + 1];
                    Строка.Расстояние = Расстояния[Номер];
                    РасчитатьРасходТопливаВСтроке(Строка, РасходТоплива);
                    ВремяЧисло = ВремяВЧисло(СтрЗаменить(ВремяМаршрута[Номер],"&#160;",""));
                    Строка.ВремяВПутиЧисло = ВремяЧисло + Цел(ВремяЧисло / 4.5) * (45/60); 
                    //Строка.ВремяВПутиЧисло = ВремяВЧисло(СтрЗаменить(ВремяМаршрута[Номер],"&#160;",""));
                    //Если Строка.ВремяВПутиЧисло >= 4.5 Тогда
                    //    Строка.ВремяВПутиЧисло = Строка.ВремяВПутиЧисло + (45/60);    	
                    //КонецЕсли; 
                    Строка.ВремяВПути = ВремяВСтроку(Строка.ВремяВПутиЧисло);
                КонецЦикла;
                
                
                //сортировка ТЧ адреса в правильном порядке
                ИндАдрес = 1; //индекс адреса в массиве Адреса
                ПозицияЗамены = 0; // это индекс строки ТЧ-Адреса, в которой  должен находиться адрес с индексом ИндАдрес
                
                //позиция замены стоит наместе пока позиция сравнения не найдет нужный адрес
                
                Пока ИндАдрес < Адреса.Количество() - 1 Цикл
                    Для ПозицияСравнения = ПозицияЗамены по Объект.Адреса.Количество() - 1 Цикл
                        Если НЕ Адреса[ИндАдрес] = Объект.Адреса[ПозицияСравнения].Адрес Тогда
                            Продолжить;
                        Иначе
                            ВремДок = Объект.Адреса[ПозицияЗамены].Документ;
                            Объект.Адреса[ПозицияСравнения].Адрес = Объект.Адреса[ПозицияЗамены].Адрес;
                            
                            Объект.Адреса[ПозицияЗамены].Документ = Объект.Адреса[ПозицияСравнения].Документ;
                            Объект.Адреса[ПозицияСравнения].Документ = ВремДок;
                            Объект.Адреса[ПозицияЗамены].Адрес = Адреса[ИндАдрес];
                            
                            ПозицияЗамены = ПозицияЗамены + 1;
                        КонецЕсли;
                    КонецЦикла;
                    ИндАдрес = ИндАдрес + 1;
                КонецЦикла;
                
            КонецЕсли;
            
        ИначеЕсли ДанныеСобытия.event.eventType = "Перерасчет" Тогда
            Расстояния = СтрРазделить(ДанныеСобытия.event.dist, "~", Ложь);
            ВремяМаршрута = СтрРазделить(ДанныеСобытия.event.times, "|", Ложь); 
            
            Для Номер = 0 по Объект.Маршруты.Количество() - 1 Цикл
                ТекСтрокаМаршруты = Объект.Маршруты[Номер];
                ТекСтрокаМаршруты.Расстояние = Число(Расстояния[Номер]);
                РасчитатьРасходТопливаВСтроке(ТекСтрокаМаршруты, РасходТоплива);
                
                //преобразует строку 2 д 10 ч 30 мин - в 2д 10ч 30мин 
                КомпонентыВремени = СтрРазделить(ВремяМаршрута[Номер], " ", ложь); //КомпВремени = ["2", "д", "10", "ч", "30", "мин"]
                СтрокаВремени = ""; 
                Инд = 0;
                Пока Инд <= КомпонентыВремени.Количество() - 2 Цикл
                    СтрокаВремени = СтрокаВремени + КомпонентыВремени[Инд] + КомпонентыВремени[Инд + 1] + " ";
                    Инд = Инд + 2;
                КонецЦикла;
                
                ТекСтрокаМаршруты.ВремяВПути = СтрокаВремени;
                ТекСтрокаМаршруты.ВремяВПутиЧисло = ВремяВЧисло(СтрокаВремени);
            КонецЦикла;
            
        КонецЕсли;
        
        
        Расстояние = Объект.Маршруты.Итог("Расстояние");
        Топливо = Объект.Маршруты.Итог("РасходТоплива");
        
        //Топливо = РасходТопливаОбщий;
        //
        //ВсегоДней = 0;
        //ВсегоЧасов = 0;
        //ВсегоМинут = 0;
        //
        //Для каждого строка Из Объект.Маршруты Цикл
        //	КомпВремени = СтрРазделить(строка.ВремяВПути," ",Ложь);
        //	Для Каждого Комп Из КомпВремени Цикл
        //		Если СтрНайти(Комп, "мин") <> 0 Тогда
        //			ВсегоМинут = ВсегоМинут + Число(СтрЗаменить(Комп,"мин", ""));
        //			Продолжить;	
        //		Иначе
        //			Если СтрНайти(Комп, "ч") <> 0 Тогда
        //				ВсегоЧасов = ВсегоЧасов + Число(СтрЗаменить(Комп,"ч", ""));
        //				Продолжить;	
        //			Иначе
        //				Если СтрНайти(Комп, "д") <> 0 Тогда
        //					ВсегоДней = ВсегоДней + Число(СтрЗаменить(Комп,"д", ""));
        //					Продолжить;
        //				КонецЕсли;
        //			КонецЕсли;
        //		КонецЕсли; 
        //		
        //	КонецЦикла;
        //КонецЦикла;
        //
        //ВсегоЧасов = ВсегоЧасов + Цел(ВсегоМинут/60);
        //ВсегоМинут = ВсегоМинут % 60;
        //
        //ВсегоДней = ВсегоДней + Цел(ВсегоЧасов / 24);
        //ВсегоЧасов = ВсегоЧасов % 24;
        //
        
        элементы.МаршрутыВремяВПути.ТекстПодвала = ВремяВСтроку(Объект.Маршруты.Итог("ВремяВПутиЧисло"));//""+ ВсегоДней + "д. " + ВсегоЧасов + "ч. " + ВсегоМинут + "мин.";
        ВремяВПути = Объект.Маршруты.Итог("ВремяВПутиЧисло");
        
        ЦенаЗаЛитр = УзнатьЦенуБензина(Объект.ТранспортноеСредство);
        Если ЦенаЗаЛитр = 0 Тогда 	
            Сообщить("у топлива не установлена цена");
        Иначе
            СтоимостьТоплива = Топливо * ЦенаЗаЛитр;	
        КонецЕсли; 	
        
        Элементы.ПолеЯндексКарты.Доступность = Истина; 
        Элементы.ПодтвердитьМаршрутИЗакрыть.Доступность = Истина;
        Элементы.Подтвердить.Доступность = Истина;
        
    КонецЕсли;	
КонецПроцедуры

&НаСервереБезКонтекста
Функция ВремяВЧисло(Время)
    ВсегоДней = 0;
    ВсегоЧасов = 0;
    ВсегоМинут = 0;
    
    КомпВремени = СтрРазделить(Время," ",Ложь);  // Строка - 2д 10ч 30мин, КомпВремени = ["2д", "10ч", "30мин"]
    Для Каждого Комп Из КомпВремени Цикл
        Если СтрНайти(Комп, "мин") <> 0 Тогда
            ЧислоСтр = СтрЗаменить(Комп,"мин", "");
            Если ЧислоСтр = ""  Тогда
                ЧислоСтр = "0";	
            КонецЕсли;
            ВсегоМинут = ВсегоМинут + Число(ЧислоСтр);
            Продолжить;	
        ИначеЕсли СтрНайти(Комп, "ч") <> 0 Тогда
            ЧислоСтр = СтрЗаменить(Комп,"ч", "");
            Если ЧислоСтр = ""  Тогда
                ЧислоСтр = "0";	
            КонецЕсли;
            ВсегоЧасов = ВсегоЧасов + Число(ЧислоСтр);
            Продолжить;	
        ИначеЕсли СтрНайти(Комп, "д") <> 0 Тогда 
            ЧислоСтр = СтрЗаменить(Комп,"д", "");
            Если ЧислоСтр = ""  Тогда
                ЧислоСтр = "0";	
            КонецЕсли;
            ВсегоДней = ВсегоДней + Число(ЧислоСтр);
            Продолжить;
        КонецЕсли;
    КонецЦикла;
    
    ВсегоЧасов = ВсегоЧасов + Цел(ВсегоМинут/60);
    ВсегоМинут = ВсегоМинут % 60; 
    
    Возврат ВсегоДней * 24 + ВсегоЧасов + ВсегоМинут/60;	
КонецФункции

&НаКлиенте
Процедура ТранспортноеСредствоПриИзменении(Элемент)
    ПолучениеИнформацииОТранспорте(Объект.ТранспортноеСредство);	
КонецПроцедуры

&НаКлиенте
Процедура ПолучениеИнформацииОТранспорте(ТС)
    ГрузоподъемностьМашины = ОбщегоНазначенияУТВызовСервера.ЗначениеРеквизитаОбъекта(ТС,"ГрузоподъемностьВТоннах") * 1000; 
    МассаТоваровДоставки = ВладелецФормы.Объект.МассаБрутто;
    Если ГрузоподъемностьМашины < МассаТоваровДоставки Тогда
        Сообщить("Грузоподъемность машины меньше, чем масса груза");
        ТС = Неопределено;
        Возврат;
    ИначеЕсли МассаТоваровДоставки = 0 Тогда 
        Сообщить("не рассчитана масса груза, невозможно провести учет грузоподъемности");
        ТС = Неопределено;
        Возврат;
    КонецЕсли;            
    
    //ВидТоплива = ПолучитьВидТоплива();  
    ВидТоплива = ОбщегоНазначенияУТВызовСервера.ЗначениеРеквизитаОбъекта(ТС,"Рейс_ВидТоплива");
    РасходТоплива = ПолучитьРасходЛитровНаСервере(ТС);
    
    ЦенаЗаЛитр = УзнатьЦенуБензина(ТС);
    Если ЦенаЗаЛитр = 0 Тогда 
        Сообщить("у топлива не установлена цена");
        Возврат;
    КонецЕсли;
    
    
    Для Каждого Строка из Объект.Маршруты Цикл
        РасчитатьРасходТопливаВСтроке(Строка, РасходТоплива);
    КонецЦикла;
    Топливо = Объект.Маршруты.Итог("РасходТоплива");
    
    Если Топливо <> 0 Тогда
        СтоимостьТоплива = Топливо * ЦенаЗаЛитр;	
    КонецЕсли;
КонецПроцедуры // ПолучениеИнформацииОТранспорте()

&НаСервере
Функция УзнатьЦенуБензина(ТранспортноеСредство)
    
    СтруктураПараметровОтбора = ЦеныПредприятияЗаполнениеСервер.НовыйПараметрыОтбораПолучитьЦенуПоОтбору();
    СтруктураПараметровОтбора.Вставить("Дата",ТекущаяДата());
    СтруктураПараметровОтбора.Вставить("Валюта", Справочники.Валюты.НайтиПоНаименованию("RUB"));
    СтруктураПараметровОтбора.Вставить("ВидЦены", Справочники.ВидыЦен.НайтиПоНаименованию("Розничная"));
    СтруктураПараметровОтбора.Вставить("Номенклатура", ТранспортноеСредство.Рейс_ВидТоплива);
    
    Возврат ЦеныПредприятияЗаполнениеСервер.ПолучитьЦенуПоОтбору(СтруктураПараметровОтбора);
    
    //Запрос = Новый Запрос;
    //Запрос.Текст = 
    //	"ВЫБРАТЬ
    //	|	ЦеныНоменклатуры25СрезПоследних.Цена КАК Цена
    //	|ИЗ
    //	|	РегистрСведений.ЦеныНоменклатуры25.СрезПоследних(, Номенклатура = &Номенклатура) КАК ЦеныНоменклатуры25СрезПоследних";
    //
    //Запрос.УстановитьПараметр("Номенклатура", Объект.ТранспортноеСредство.Рейс_ВидТоплива);
    //
    //РезультатЗапроса = Запрос.Выполнить();
    //
    //ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
    //
    //Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
    //	Возврат ВыборкаДетальныеЗаписи.Цена;
    //КонецЦикла;
    //   	Возврат 0;
КонецФункции

//Поиск адреса Точки оптравления(склады)
&НаСервере
Функция ТочкаОтправленияПриИзмененииНаСервере()
    
    Результат = УправлениеКонтактнойИнформацией.КонтактнаяИнформацияОбъекта(Объект.ТочкаОтправления, Справочники.ВидыКонтактнойИнформации.АдресСклада, Текущаядата());
    Возврат Результат;     
    
КонецФункции

&НаКлиенте
Процедура ТочкаОтправленияПриИзменении(Элемент)	 
    АдресТочкиОтправления = ТочкаОтправленияПриИзмененииНаСервере();
    Если НЕ ЗначениеЗаполнено(АдресТочкиОтправления) Тогда
        Сообщить("Текущий склад не имеет адреса");
        Объект.ТочкаОтправления = Неопределено;
    Иначе
        Объект.Маршруты[0].От = АдресТочкиОтправления;
        Объект.Маршруты[Объект.Маршруты.Количество() - 1].До = АдресТочкиОтправления; 
        
        //Объект.ВремяМаршрутов[0].От = АдресТочкиОтправления;
        //Объект.ВремяМаршрутов[Объект.ВремяМаршрутов.Количество() - 1].До = АдресТочкиОтправления;
    КонецЕсли;
КонецПроцедуры

//БСП
&НаСервере
Функция АдресаДокументПриИзмененииНаСервере(Ссылка)
    Возврат ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Ссылка, "АдресДоставки").АдресДоставки;
    
    //Запрос = Новый Запрос;
    //Запрос.Текст = 
    //"ВЫБРАТЬ
    //|	РеализацияТоваровУслуг.АдресДоставки КАК АдресДоставки
    //|ИЗ
    //|	Документ.РеализацияТоваровУслуг КАК РеализацияТоваровУслуг
    //|ГДЕ
    //|	РеализацияТоваровУслуг.Ссылка = &Ссылка";
    //
    //Запрос.УстановитьПараметр("Ссылка", Ссылка);
    //
    //РезультатЗапроса = Запрос.Выполнить();
    //
    //ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
    //
    //Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
    //	Возврат ВыборкаДетальныеЗаписи.АдресДоставки;
    //КонецЦикла;
КонецФункции

&НаКлиенте
Процедура АдресаДокументПриИзменении(Элемент)
    Строка = Элементы.Адреса.ТекущиеДанные;
    АдресДокумента = АдресаДокументПриИзмененииНаСервере(Строка.Документ);
    
    Если НЕ ЗначениеЗаполнено(АдресДокумента) Тогда
        Сообщить("Текущая реализация не имеет адреса доставки");
        Объект.Адреса.Удалить(Строка);
    Иначе
        Строка.Адрес = АдресДокумента;	
    КонецЕсли; 	
КонецПроцедуры

&НаКлиенте
Процедура ПодтвердитьМаршрутИЗакрыть(Команда)
    //Если ПроверкаНаБлокировкуРегистров() Тогда
    //    Возврат;	
    //КонецЕсли;
   // ПроверкаНаБлокировкуРегистров(ВладелецФормы.Объект.Ссылка);
    ПереносДокументов();
    ЗаписьВРегистрРейтингРасстояний(ВладелецФормы.Объект.Ссылка, ВладелецФормы.Объект.Водитель, ВладелецФормы.Объект.Дата);
    ЗаписьВРегистрСведений(ВладелецФормы.Объект.Ссылка, ВладелецФормы.Объект.Дата);	
    ЭтаФорма.Закрыть();
    
КонецПроцедуры 

&НаКлиенте
Процедура ПодтвердитьМаршрут(Команда)
    
    ПереносДокументов();
    ЗаписьВРегистрРейтингРасстояний(ВладелецФормы.Объект.Ссылка, ВладелецФормы.Объект.Водитель, ВладелецФормы.Объект.Дата);
    ЗаписьВРегистрСведений(ВладелецФормы.Объект.Ссылка, ВладелецФормы.Объект.Дата);
КонецПроцедуры

//вроде не работает
&НаСервереБезКонтекста
Функция ПроверкаНаБлокировкуРегистров(Ссылка)
    //Если РегистрыСведений.Рейс_ВремяМаршрутов.ПолучитьОбъект().Заблокирован()ИЛИ РегистрыНакопления.Рейс_РейтингРасстояний.Заблокирован() Тогда
    //    Возврат Истина;
    //Иначе
    //    Возврат Ложь;    
    //КонецЕсли;
    Набор = РегистрыСведений.Рейс_ВремяМаршрутов.СоздатьНаборЗаписей();
    Набор.Отбор.ДокументМаршрута.Установить(Ссылка);
    Попытка
    
    	Набор.Прочитать();
    
    Исключение
       Сообщить("блок");
    КонецПопытки;    
    
КонецФункции // ПроверкаНаБлокировкуРегистра()

&НаСервере
Процедура ЗаписьВРегистрСведений(ДокументСсылка, Дата)
    Если ДокументСсылка.Пустая() Тогда
        Возврат;
    КонецЕсли;
    
    НаборЗаписей = РегистрыСведений.Рейс_ВремяМаршрутов.СоздатьНаборЗаписей();
    НаборЗаписей.Отбор.ДокументМаршрута.Установить(ДокументСсылка);
    
    Блокировка = Новый БлокировкаДанных;
    ЭлементБлокировки = Блокировка.Добавить();
    ЭлементБлокировки.Область = "РегистрСведений.Рейс_ВремяМаршрутов";
    ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
    ЭлементБлокировки.ИсточникДанных = Объект.Маршруты.Выгрузить();
    ЭлементБлокировки.УстановитьЗначение("Период", Дата);
    ЭлементБлокировки.ИспользоватьИзИсточникаДанных("ТочкаОтправления", "От");
    ЭлементБлокировки.ИспользоватьИзИсточникаДанных("ТочкаПрибытия", "До");
    НачатьТранзакцию(РежимУправленияБлокировкойДанных.Управляемый);
    Блокировка.Заблокировать();
    
    Для Каждого Строка Из Объект.Маршруты Цикл
        Если ЗначениеЗаполнено(Строка.ВремяВПути) Тогда	
            НоваяЗапись = НаборЗаписей.Добавить();
            НоваяЗапись.Период = Дата;
            НоваяЗапись.ДокументМаршрута = ДокументСсылка; 
            НоваяЗапись.ТочкаОтправления = Строка.От;
            НоваяЗапись.ТочкаПрибытия = Строка.До; 
            
            НоваяЗапись.ОжидаемоеВремя = ВремяВЧисло(Строка.ВремяВПути);
        КонецЕсли;
    КонецЦикла;
    Если НаборЗаписей.Количество() <> 0 Тогда
        НаборЗаписей.Записать();
    КонецЕсли;
    
    Для Каждого Строка из Объект.Маршруты Цикл
        Если ЗначениеЗаполнено(Строка.ФактВремя) Тогда
            НаборЗаписей = РегистрыСведений.Рейс_ВремяМаршрутов.СоздатьНаборЗаписей(); 
            НаборЗаписей.Отбор.ДокументМаршрута.Установить(ДокументСсылка);
            НаборЗаписей.Отбор.ТочкаОтправления.Установить(Строка.От);
            НаборЗаписей.Отбор.ТочкаПрибытия.Установить(Строка.До);
            НаборЗаписей.Прочитать();
            Для Каждого Запись из НаборЗаписей Цикл
                
                Запись.ФактВремя = ВремяВЧисло(Строка.ФактВремя);
                Запись.Авария = Строка.Авария;
                
            КонецЦикла;
            НаборЗаписей.Записать(РежимЗамещения.Замещение);
        КонецЕсли;
    КонецЦикла;	
    ЗафиксироватьТранзакцию();
КонецПроцедуры

&НаСервере
Процедура ЗаписьВРегистрРейтингРасстояний(Ссылка, Водитель, Дата)
    
    Движения = РегистрыНакопления.Рейс_РейтингРасстояний.СоздатьНаборЗаписей();
    Движения.Отбор.Регистратор.Установить(Ссылка);
    Для Каждого Строка из Объект.Маршруты Цикл
        Если Не ЗначениеЗаполнено(Строка.Расстояние) Тогда
            Продолжить;
        КонецЕсли;
        
        Запись 			   = Движения.Добавить();
        Запись.Регистратор = Ссылка;
        Запись.Водитель	   = Водитель;
        Запись.Период 	   = Дата;
        Запись.Расстояние  = Строка.Расстояние;
    КонецЦикла;
    Движения.БлокироватьДляИзменения = Истина;
    Если Движения.Количество() > 0 Тогда
        
        Движения.Записать();	
        
    КонецЕсли;
    
    
КонецПроцедуры

&НаКлиенте
Процедура ПереносДокументов()
    
    НомерСтрокиТранспортной = 0;
    ТЧТранспортной =  ВладелецФормы.Объект.ДокументыОснования;
    Пока НомерСтрокиТранспортной < ТЧТранспортной.Количество() Цикл
        Док =  ТЧТранспортной[НомерСтрокиТранспортной].ДокументОснование; 
        
        Если ТипЗнч(Док) = Тип("ДокументСсылка.РеализацияТоваровУслуг") Тогда
            АдресДокумента = АдресаДокументПриИзмененииНаСервере(Док);
            
            Если ЗначениеЗаполнено(АдресДокумента) Тогда
                ТЧТранспортной.Удалить(ТЧТранспортной[НомерСтрокиТранспортной]);
                Продолжить;
            КонецЕсли;  
            
        КонецЕсли;
        НомерСтрокиТранспортной = НомерСтрокиТранспортной + 1;
    КонецЦикла;
    
    НомерСтрокиАдресов = Объект.Адреса.Количество() - 1;
    Пока НомерСтрокиАдресов >= 0 Цикл
        НоваяСтрока = ВладелецФормы.Объект.ДокументыОснования.Вставить(0);
        НоваяСтрока.ДокументОснование = Объект.Адреса[НомерСтрокиАдресов].Документ;
        //Объект.Адреса[НомерСтрокиАдресов].Документ.ПолучитьОбъект().Разблок()
        НомерСтрокиАдресов = НомерСтрокиАдресов - 1;
    КонецЦикла;
    
    ВладелецФормы.Записать(Новый Структура("РежимЗаписи", РежимЗаписиДокумента.Запись));
    
КонецПроцедуры

&НаКлиенте
Процедура Пересчитать(Команда)
    Элементы.ПолеЯндексКарты.Документ.DefaultView.recalculate();
КонецПроцедуры

&НаКлиенте
Процедура РасчитатьРасходТопливаВСтроке(Строка, РасходТоплива)
    
    Если РасходТоплива = 0 Тогда
        Сообщить("В регистре нет записи по этому транспортному средству");
        Строка.РасходТоплива = 0;
    Иначе
        Попытка
            Строка.РасходТоплива = ((Строка.Расстояние)/100) * Число(РасходТоплива);
        Исключение
            Сообщить("Не удалось расчитать расход топлива в строке " + Строка.НомерСтроки + 1);
            Строка.РасходТоплива = 0;
        КонецПопытки;
    КонецЕсли;
    
КонецПроцедуры

&НаКлиенте
Процедура РасчитатьОтклонения(Команда)	
    Если НЕ ЗначениеЗаполнено(Объект.ТочкаОтправления) Тогда
        Сообщить("Точка отправления не заполнена");
        Возврат;		
    КонецЕсли;  
    
    ЗаписьВРегистрСведений(ВладелецФормы.Объект.Ссылка, ВладелецФормы.Объект.Дата);
    
    Для Каждого Строка из Объект.Маршруты Цикл
        ОжидаемоеВремя	 = 0;
        ФактическоеВремя = 0;
        
        СтруктураВремен = ПолучитьВременаМаршрута(ВладелецФормы.Объект.Ссылка, Строка.От, Строка.До);			
        Если СтруктураВремен.Свойство("ОжидаемоеВремя",ОжидаемоеВремя) Тогда
            Строка.ВремяВПути = ВремяВСтроку(ОжидаемоеВремя);
            СтруктураВремен.Свойство("ФактическоеВремя", ФактическоеВремя);
            Строка.ФактВремя = ВремяВСтроку(ФактическоеВремя);
        КонецЕсли;
        Если НЕ ОжидаемоеВремя = Неопределено Тогда
            Строка.Отклонение  = ((ФактическоеВремя * 100) / ОжидаемоеВремя) - 100;	
        КонецЕсли;
        СтруктураВремен.Свойство("Авария", Строка.Авария); 
    КонецЦикла;
    
КонецПроцедуры 

&НаСервереБезКонтекста
Функция ВремяВСтроку(Время)
    
    Минуты = Окр((Время - Цел(Время)) * 60, 0); 
    Дни    = Цел(Время/24);
    Час	= Цел(Время % 24);
    Возврат "" + Дни + "д " + Час + "ч " + Минуты + "мин";
    
КонецФункции

&НаКлиенте
Процедура ПередУдалениемЭлементаТЧ(Элемент, Отказ)
    Отказ = Истина;
КонецПроцедуры




